# D-06 エラーハンドリング詳細設計書 (r6)

## 1. 概要

### 1.1 目的

本ドキュメントは、EAP-AKA RADIUS PoC環境を構成する各コンポーネントにおける異常系の検出・対処・復旧方針を定義し、システム全体の耐障害性と運用性を確保することを目的とする。

### 1.2 対象範囲

本書で扱うコンポーネント：

| コンポーネント | 役割 | 主な異常系 |
|---------------|------|-----------|
| **Auth Server** | RADIUS認証、EAP-AKA/AKA'制御 | Vector Gateway障害、Valkey障害、不正パケット、認証失敗 |
| **Acct Server** | RADIUS課金 | Valkey障害、不正パケット、セッション不整合 |
| **Vector Gateway** | ルーティング、ベクター取得先振分け | Vector API障害、ルーティングエラー、リクエスト不正 |
| **Vector API** | 認証ベクター計算 | Valkey障害、計算エラー、IMSI不在 |
| **Admin TUI** | 管理コンソール | Valkey障害、入力エラー、インポートエラー |

**注記：** Valkey、Fluent Bit、Docker Compose、ホストOS（UFW等）のインフラ層設定については「インフラ設定・運用設計書」で別途定義する。

### 1.3 PoC対象外機能

本PoCでは以下の機能は実装対象外とする：

| 機能 | 説明 | 受信時の対処 |
|------|------|-------------|
| 仮名認証 | Pseudonym IDによる認証 | フル認証へ誘導 |
| 高速再認証 | Fast Re-authentication | フル認証へ誘導 |
| EAP-Notification | 通知メッセージ送信 | 使用しない |
| 外部API接続方式 | Vector Gatewayからの外部API連携 | 501 Not Implemented返却 |

### 1.4 関連ドキュメント

| ドキュメント | 内容 |
|-------------|------|
| Valkeyデータ設計仕様書 (r10) | データ構造、TTL設定 |
| Vector-APIインターフェース定義書およびEAP-AKAステートマシン設計書 (r5) | API仕様、状態遷移、Vector Gateway経由接続 |
| ログ仕様設計書 (r13) | ログフォーマット、event_id定義 |
| Admin TUI詳細設計書【前半】(r5) | TUI画面仕様、バリデーション |
| ミニPC版EAP-AKA RADIUS PoC環境設計仕様書 (r9) | システム構成、パッケージ利用 |
| Vector Gateway実装レベル検討書 (r1) | ルーティング設計、接続方式設計 |

---

## 2. エラー分類と重大度

### 2.1 エラーカテゴリ定義

| カテゴリ | 説明 | 例 |
|---------|------|-----|
| **通信エラー (COMM)** | 外部システムとの接続・通信障害 | Valkey接続断、Vector Gateway/APIタイムアウト |
| **プロトコルエラー (PROTO)** | RADIUS/EAPプロトコル違反 | 不正パケット形式、未知のEAPタイプ |
| **ルーティングエラー (ROUTE)** | ルーティング処理の失敗 | 未実装バックエンド、PLMN不正 |
| **データエラー (DATA)** | データの不整合・不在 | IMSI未登録、ポリシー未設定、SQN不整合 |
| **認証エラー (AUTH)** | 認証処理の失敗 | RES不一致、MAC検証失敗 |
| **システムエラー (SYS)** | 内部的な予期せぬ障害 | メモリ不足、Panic |

### 2.2 重大度レベル定義

| レベル | 定義 | ログレベル | 対応方針 |
|--------|------|-----------|---------|
| **Critical** | サービス継続不可 | ERROR | 即座に運用者通知、復旧優先 |
| **Error** | 個別リクエスト失敗 | ERROR/WARN | ログ記録、リクエスト拒否 |
| **Warning** | 潜在的問題 | WARN | ログ記録、監視対象 |
| **Info** | 正常範囲内の注目イベント | INFO | ログ記録 |

---

## 3. コンポーネント別エラー処理

### 3.1 Auth Server

#### 3.1.1 通信エラー

##### Vector Gateway接続エラー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| 接続失敗 | TCP接続エラー | Circuit Breaker カウント | EAP-Failure + Access-Reject | ERROR: `VECTOR_API_ERR` |
| タイムアウト | 応答なし（5秒超過） | Circuit Breaker カウント | EAP-Failure + Access-Reject | ERROR: `VECTOR_API_ERR` |
| HTTPエラー（4xx） | ステータスコード400番台 | エラー内容に応じた処理 | EAP-Failure + Access-Reject | ERROR/WARN: `VECTOR_API_ERR` |
| HTTPエラー（5xx） | ステータスコード500番台 | Circuit Breaker カウント | EAP-Failure + Access-Reject | ERROR: `VECTOR_API_ERR` |
| HTTPエラー（501） | 未実装バックエンド | ログ記録 | EAP-Failure + Access-Reject | WARN: `VECTOR_API_ERR` |
| Circuit Breaker Open | CB状態がOpen | API呼び出しスキップ | EAP-Failure + Access-Reject | WARN: `CB_OPEN` (状態遷移時) |

> **注記：** Auth ServerからはVector Gatewayに対して接続する。Vector Gatewayが501 Not Implementedを返却した場合は、未実装の接続方式IDが使用されたことを意味する。

##### Valkey接続エラー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| 接続失敗 | TCP接続エラー | リトライ（2回、指数バックオフ） | EAP-Failure + Access-Reject | ERROR: `VALKEY_CONN_ERR` |
| コマンドタイムアウト | 応答なし（2秒超過） | リトライ | EAP-Failure + Access-Reject | ERROR: `VALKEY_CONN_ERR` |
| 認証失敗 | AUTH失敗 | 起動時エラー終了 | - | ERROR: `VALKEY_AUTH_ERR` |

#### 3.1.2 プロトコルエラー

##### RADIUSレイヤー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| パケットパース失敗 | 不正なRADIUS形式 | パケット破棄 | なし（応答しない） | WARN: `RADIUS_PARSE_ERR` |
| Shared Secret不一致 | Message-Authenticator検証失敗 | パケット破棄 | なし（応答しない） | WARN: `RADIUS_AUTH_ERR` |
| Shared Secret不明 | client:{IP}不在かつ環境変数未設定 | パケット破棄 | なし（応答しない） | WARN: `RADIUS_NO_SECRET` |
| 未知のRADIUSコード | 不正なCode値 | パケット破棄 | なし（応答しない） | WARN: `RADIUS_UNKNOWN_CODE` |

**理由：** RADIUSレイヤーの不正パケットは「信頼できない送信元」の可能性があるため、RFC 2865に準拠し応答しない。

##### EAPレイヤー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| EAPパケットパース失敗 | 不正なEAP形式 | EAP-Failure送信 | Access-Reject | WARN: `EAP_PARSE_ERR` |
| 未知のEAPサブタイプ | 不正なAT_xxx | EAP-Failure送信 | Access-Reject | WARN: `EAP_UNKNOWN_SUBTYPE` |
| 非対応EAP方式 | EAP-SIM等 | EAP-Failure送信 | Access-Reject | INFO: `EAP_UNSUPPORTED_TYPE` |
| Identity形式不正 | IMSI抽出失敗 | EAP-Failure送信 | Access-Reject | WARN: `EAP_IDENTITY_INVALID` |

##### EAP Identity判定ロジック

| Identity形式 | 先頭文字 | 認証方式 | 対応状況 | 対処 |
|-------------|---------|---------|---------|------|
| `0<IMSI>@<realm>` | 0 | EAP-AKA 永続識別子 | 対応 | 正常処理継続 |
| `2<仮名>@<realm>` | 2 | EAP-AKA 仮名 | 非対応 | フル認証へ誘導 |
| `4<再認証ID>@<realm>` | 4 | EAP-AKA 高速再認証 | 非対応 | フル認証へ誘導 |
| `6<IMSI>@<realm>` | 6 | EAP-AKA' 永続識別子 | 対応 | 正常処理継続 |
| `7<仮名>@<realm>` | 7 | EAP-AKA' 仮名 | 非対応 | フル認証へ誘導 |
| `8<再認証ID>@<realm>` | 8 | EAP-AKA' 高速再認証 | 非対応 | フル認証へ誘導 |
| `1<IMSI>@<realm>` | 1 | EAP-SIM 永続識別子 | 非対応 | EAP-Failure + Access-Reject |
| `3<仮名>@<realm>` | 3 | EAP-SIM 仮名 | 非対応 | EAP-Failure + Access-Reject |
| `5<再認証ID>@<realm>` | 5 | EAP-SIM 高速再認証 | 非対応 | EAP-Failure + Access-Reject |
| `[0-9]<IMSI>` (realmなし) | 0-9 | 不明 | 非対応 | EAP-Failure + Access-Reject |
| その他 | - | 不明 | 非対応 | EAP-Failure + Access-Reject |

##### フル認証への誘導（仮名/高速再認証受信時）

仮名(2,7)または高速再認証ID(4,8)を含むIdentityを受信した場合、永続識別子による再認証を要求する。RFC 4187 Section 4.1.4 に基づき、`AT_PERMANENT_ID_REQ` を使用する。

```
[Client]                              [Auth Server]
    |                                      |
    |  EAP-Response/Identity               |
    |  (Identity: 2<pseudonym>@realm)      |
    |------------------------------------->|
    |                                      |
    |  EAP-Request/AKA-Identity            |
    |  (AT_PERMANENT_ID_REQ)               |
    |<-------------------------------------|
    |                                      |
    |  EAP-Response/AKA-Identity           |
    |  (AT_IDENTITY: 0<IMSI>@realm)        |
    |------------------------------------->|
    |                                      |
    |  (通常のフル認証フローへ継続)          |
```

**注記：**
- EAP-AKA の場合: `EAP-Request/AKA-Identity` に `AT_PERMANENT_ID_REQ` を含めて送信
- EAP-AKA' の場合: `EAP-Request/AKA'-Identity` に `AT_PERMANENT_ID_REQ` を含めて送信
- クライアントは永続識別子（IMSI）を `AT_IDENTITY` に格納して応答する

##### EAP-AKA/AKA'固有エラー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| AKA-Client-Error受信 | AT_CLIENT_ERROR_CODE含む | ログ記録 | EAP-Failure + Access-Reject | WARN: `EAP_CLIENT_ERROR` |
| AKA-Authentication-Reject受信 | クライアントがAUTN検証失敗 | ログ記録 | EAP-Failure + Access-Reject | WARN: `EAP_AUTH_REJECT` |
| AKA-Synchronization-Failure受信 | SQN不整合 | Vector Gateway再同期呼び出し | （再同期後に再Challenge） | INFO: `SQN_RESYNC` |
| 再同期連続失敗 | 同一セッションで再同期32回超過 | 認証失敗 | EAP-Failure + Access-Reject | WARN: `AUTH_RESYNC_LIMIT` |

**再同期リトライ上限について：**
- 上限値: 32回
- 根拠: SQN の IND (Index) フィールドが5ビット（0-31）であり、1サイクル分の試行を許容
- 32回を超えた場合は、SIM側またはネットワーク側に深刻な問題があると判断し、認証を拒否

#### 3.1.3 認証エラー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| RES不一致 | AT_RESとXRESが一致しない | 認証失敗 | EAP-Failure + Access-Reject | WARN: `AUTH_RES_MISMATCH` |
| MAC検証失敗 | AT_MAC検証失敗 | 認証失敗 | EAP-Failure + Access-Reject | WARN: `AUTH_MAC_INVALID` |
| EAPコンテキスト期限切れ | eap:{UUID}のTTL超過 | 認証失敗 | EAP-Failure + Access-Reject | WARN: `AUTH_TIMEOUT` |

#### 3.1.4 データエラー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| IMSI未登録 | Vector Gateway経由で404応答 | 認証失敗 | EAP-Failure + Access-Reject | INFO: `AUTH_IMSI_NOT_FOUND` |
| ポリシー未設定 | policy:{IMSI}不在 | 認証失敗 | EAP-Failure + Access-Reject | INFO: `AUTH_POLICY_NOT_FOUND` |
| ポリシー不一致 | SSID/時間帯ルールが一致しない、またはアクションがdeny | 認証失敗 | EAP-Failure + Access-Reject | INFO: `AUTH_POLICY_DENIED` |
| EAPコンテキスト不在 | eap:{UUID}不在（State不正） | 認証失敗 | EAP-Failure + Access-Reject | WARN: `AUTH_CONTEXT_NOT_FOUND` |

---

### 3.2 Acct Server

#### 3.2.1 通信エラー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| Valkey接続失敗 | TCP接続エラー | リトライ（3回） | Accounting-Response（ベストエフォート） | ERROR: `VALKEY_CONN_ERR` |
| Valkeyコマンドタイムアウト | 応答なし（2秒超過） | リトライ | Accounting-Response | ERROR: `VALKEY_CONN_ERR` |

**注記：** Valkey障害時も課金パケットにはAccounting-Responseを返す（クライアントの再送を防ぐため）。データ欠損はログから追跡可能とする。

#### 3.2.2 プロトコルエラー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| パケットパース失敗 | 不正なRADIUS形式 | パケット破棄 | なし | WARN: `RADIUS_PARSE_ERR` |
| Shared Secret不一致 | Authenticator検証失敗 | パケット破棄 | なし | WARN: `RADIUS_AUTH_ERR` |
| Shared Secret不明 | client:{IP}不在かつ環境変数未設定 | パケット破棄 | なし | WARN: `RADIUS_NO_SECRET` |
| 未知のAcct-Status-Type | 不正な値 | パケット破棄 | なし | WARN: `RADIUS_UNKNOWN_CODE` |

#### 3.2.3 データエラー

| エラー種別 | 検出条件 | 対処 | RADIUS応答 | ログ |
|-----------|---------|------|-----------|------|
| セッション不在 | sess:{UUID}不在 | 警告ログ、処理継続 | Accounting-Response | WARN: `ACCT_SESSION_NOT_FOUND` |
| セッションTTL超過 | sess:{UUID}がTTL(24h)で自動削除済み | 警告ログ、処理継続 | Accounting-Response | WARN: `ACCT_SESSION_EXPIRED` |
| 重複パケット | 同一Acct-Session-Idの重複Start | 警告ログ、処理継続 | Accounting-Response | WARN: `ACCT_DUPLICATE_START` |
| 順序異常 | StopなしでStartが来る等 | 警告ログ、処理継続 | Accounting-Response | WARN: `ACCT_SEQUENCE_ERR` |

---

### 3.3 Vector Gateway

#### 3.3.1 通信エラー

##### Vector API接続エラー

| エラー種別 | 検出条件 | 対処 | HTTP応答 | ログ |
|-----------|---------|------|---------|------|
| 接続失敗 | TCP接続エラー | - | 502 Bad Gateway | ERROR: `BACKEND_INTERNAL_ERR` |
| タイムアウト | 応答なし（5秒超過） | - | 502 Bad Gateway | ERROR: `BACKEND_INTERNAL_ERR` |
| HTTPエラー（4xx） | ステータスコード400番台 | エラー透過 | 元のステータスコードを返却 | INFO/WARN: `BACKEND_INTERNAL_ERR` |
| HTTPエラー（5xx） | ステータスコード500番台 | - | 502 Bad Gateway | ERROR: `BACKEND_INTERNAL_ERR` |

> **注記：** Vector Gateway自体はCircuit Breakerを持たない。Circuit Breakerの責務はAuth Server側にある。

#### 3.3.2 ルーティングエラー

| エラー種別 | 検出条件 | 対処 | HTTP応答 | ログ |
|-----------|---------|------|---------|------|
| 未実装バックエンド | 接続方式ID `01`〜`99` | - | 501 Not Implemented | WARN: `BACKEND_NOT_IMPLEMENTED` |
| PLMNマップ未登録 | IMSIのPLMNがマップにない | デフォルト（Vector API）へ | - | DEBUG: `PLMN_ROUTE_UNMATCH` |

##### 未実装バックエンドエラーについて

PoC段階では接続方式ID `00`（内部Vector API）のみ実装する。PLMNマップで `01`〜`99` が指定された場合は、501 Not Implementedを返却する。

**501返却時の処理フロー：**
```
Auth Server → Vector Gateway
                    │
                    ├── PLMNマップ照合
                    │       ↓ マッチ（ID: 01〜99）
                    ├── バックエンド検索
                    │       ↓ 未実装
                    ├── 501 Not Implemented 返却
                    │
Auth Server ← 501応答
      │
      ↓
EAP-Failure + Access-Reject
```

**設計意図：**
- 未実装IDへのルーティングは設定ミスの可能性が高い
- 404 Not Found ではなく 501 Not Implemented を使用することで、「機能未実装」を明確に示す
- Circuit Breakerの発動対象外とし、正規のトラフィック（PLMN未登録）への影響を防ぐ

#### 3.3.3 リクエストエラー

| エラー種別 | 検出条件 | 対処 | HTTP応答 | ログ |
|-----------|---------|------|---------|------|
| リクエストボディ不正 | JSONパース失敗 | - | 400 Bad Request | WARN: `REQUEST_INVALID` |
| IMSI形式不正 | 15桁数字でない | - | 400 Bad Request | WARN: `REQUEST_INVALID` |
| 必須フィールド欠落 | IMSIが空 | - | 400 Bad Request | WARN: `REQUEST_INVALID` |

#### 3.3.4 HTTPエラー応答フォーマット

RFC 7807 (Problem Details for HTTP APIs) 準拠：

```json
{
  "type": "about:blank",
  "title": "Not Implemented",
  "detail": "Backend ID 01 is not implemented in this PoC version.",
  "status": 501
}
```

**エラー応答例：**

| HTTPステータス | title | detail例 |
|---------------|-------|---------|
| 400 Bad Request | Bad Request | "IMSI must be 15 digits" |
| 501 Not Implemented | Not Implemented | "Backend ID 01 is not implemented" |
| 502 Bad Gateway | Bad Gateway | "Failed to communicate with internal Vector API" |

---

### 3.4 Vector API

#### 3.4.1 通信エラー

| エラー種別 | 検出条件 | 対処 | HTTP応答 | ログ |
|-----------|---------|------|---------|------|
| Valkey接続失敗 | TCP接続エラー | リトライ（2回） | 500 Internal Server Error | ERROR: `VALKEY_CONN_ERR` |
| Valkeyコマンドタイムアウト | 応答なし（2秒超過） | リトライ | 500 Internal Server Error | ERROR: `VALKEY_CONN_ERR` |

#### 3.4.2 データエラー

| エラー種別 | 検出条件 | 対処 | HTTP応答 | ログ |
|-----------|---------|------|---------|------|
| IMSI未登録 | sub:{IMSI}不在 | - | 404 Not Found | INFO: `CALC_ERR` |
| IMSIフォーマット不正 | 15桁数字でない | - | 400 Bad Request | WARN: `CALC_ERR` |

#### 3.4.3 計算エラー

| エラー種別 | 検出条件 | 対処 | HTTP応答 | ログ |
|-----------|---------|------|---------|------|
| AUTS MAC検証失敗 | 再同期時のMAC不正 | - | 400 Bad Request | WARN: `SQN_RESYNC_MAC_ERR` |
| AUTS形式不正 | AUTS長不正（14バイトでない） | - | 400 Bad Request | WARN: `SQN_RESYNC_FORMAT_ERR` |
| SQN抽出失敗 | SQN復号失敗 | - | 400 Bad Request | WARN: `SQN_RESYNC_DECODE_ERR` |
| SQN競合上限超過 | WATCH/MULTI競合がリトライ上限（3回）を超過 | - | 409 Conflict | WARN: `SQN_CONFLICT_ERR` |
| Milenage計算エラー | 予期せぬ例外 | - | 500 Internal Server Error | ERROR: `CALC_ERR` |

#### 3.4.4 HTTPエラー応答フォーマット

RFC 7807 (Problem Details for HTTP APIs) 準拠：

```json
{
  "type": "about:blank",
  "title": "User Not Found",
  "detail": "IMSI 440101234567890 does not exist in subscriber DB.",
  "status": 404
}
```
409 Conflict（SQN競合時）:

```json
{
  "type": "about:blank",
  "title": "Conflict",
  "detail": "SQN update conflict after 3 retries for IMSI 44010*****890",
  "status": 409
}
```

---

### 3.5 Admin TUI

#### 3.5.1 通信エラー

| エラー種別 | 検出条件 | 対処 | UI表示 |
|-----------|---------|------|-------|
| Valkey接続失敗（起動時） | TCP接続エラー | 再試行ダイアログ表示 | Startup Errorスクリーン |
| Valkey接続失敗（操作中） | TCP接続エラー | エラーメッセージ表示 | ステータスバーにエラー |
| Valkeyコマンドタイムアウト | 応答なし（5秒超過） | リトライ促すメッセージ | ステータスバーにエラー |

#### 3.5.2 入力エラー

| エラー種別 | 検出条件 | 対処 | UI表示 |
|-----------|---------|------|-------|
| バリデーションエラー | 入力値が規則違反 | フィールド単位でエラー表示 | フィールド下に赤字メッセージ |
| 必須項目未入力 | 必須フィールドが空 | 保存ブロック | フィールド下に赤字メッセージ |
| 重複キー | 既存データと競合 | 上書き確認ダイアログ | 確認ダイアログ |

#### 3.5.3 インポートエラー

| エラー種別 | 検出条件 | 対処 | UI表示 |
|-----------|---------|------|-------|
| ファイル読み込み失敗 | ファイル不在、権限不足 | エラーメッセージ表示 | ステータスバーにエラー |
| CSVパースエラー | 不正なCSV形式 | エラー行一覧表示 | エラーサマリダイアログ |
| バリデーションエラー | 行データが規則違反 | エラー行一覧表示、インポート中断 | エラーサマリダイアログ |
| トランザクション失敗 | Valkeyコミット失敗 | ロールバック、エラー表示 | ステータスバーにエラー |

#### 3.5.4 モニタリングエラー

| エラー種別 | 検出条件 | 対処 | UI表示 |
|-----------|---------|------|-------|
| セッション一覧取得失敗 | SCAN失敗 | エラーメッセージ表示 | ステータスバーにエラー |
| セッション詳細取得失敗 | HGETALL失敗 | エラーメッセージ表示 | ステータスバーにエラー |

---

## 4. 耐障害性パターン

### 4.1 タイムアウト設定一覧

| 対象 | 項目 | 値 | 備考 |
|------|------|-----|------|
| Auth Server → Vector Gateway | HTTP接続タイムアウト | 2秒 | TCP接続確立まで |
| Auth Server → Vector Gateway | HTTPリクエストタイムアウト | 5秒 | レスポンス受信まで |
| Auth Server → Valkey | 接続タイムアウト | 3秒 | |
| Auth Server → Valkey | コマンドタイムアウト | 2秒 | |
| EAPコンテキスト | TTL | 60秒 | 既存仕様 |
| Acct Server → Valkey | 接続タイムアウト | 3秒 | |
| Acct Server → Valkey | コマンドタイムアウト | 2秒 | |
| Vector Gateway → Vector API | HTTPリクエストタイムアウト | 5秒 | `VECTOR_GATEWAY_INTERNAL_TIMEOUT` |
| Vector API → Valkey | 接続タイムアウト | 3秒 | |
| Vector API → Valkey | コマンドタイムアウト | 2秒 | |
| Admin TUI → Valkey | 接続タイムアウト | 5秒 | 対話的操作のため余裕 |
| Admin TUI → Valkey | コマンドタイムアウト | 5秒 | 対話的操作のため余裕 |

### 4.2 リトライ戦略

| 対象 | リトライ回数 | 初回間隔 | バックオフ | 備考 |
|------|------------|---------|-----------|------|
| Auth Server → Vector Gateway | 0回 | - | - | Circuit Breakerに委ねる |
| Auth Server → Valkey | 2回 | 100ms | 指数（×2） | 最大400ms待機 |
| Acct Server → Valkey | 3回 | 100ms | 指数（×2） | 最大800ms待機 |
| Vector Gateway → Vector API | 0回 | - | - | リトライなし（Auth Server側のCBに委ねる） |
| Vector API → Valkey | 2回 | 100ms | 指数（×2） | 最大400ms待機 |
| Admin TUI → Valkey | 0回（手動） | - | - | ユーザーに再試行を促す |

#### リトライ実装例

```go
func withRetry(ctx context.Context, maxRetries int, baseInterval time.Duration, fn func() error) error {
    var lastErr error
    for i := 0; i <= maxRetries; i++ {
        if err := fn(); err != nil {
            lastErr = err
            if i < maxRetries {
                interval := baseInterval * time.Duration(1<<i) // 指数バックオフ
                time.Sleep(interval)
                continue
            }
        }
        return nil
    }
    return lastErr
}
```

### 4.3 Circuit Breaker設定

Auth Server → Vector Gateway 間の通信に適用。

| 項目 | 値 | 説明 |
|------|-----|------|
| 失敗閾値 | 5回 | Closed → Open 遷移条件 |
| 計測ウィンドウ | 10秒 | 失敗カウントのリセット間隔 |
| Open状態維持時間 | 30秒 | Half-Open へ遷移するまでの時間 |
| Half-Open許可リクエスト数 | 3回 | 試行成功で Closed 復帰 |
| 成功閾値 | 2回 | Half-Open → Closed 遷移条件 |

> **注記：** r3でAuth Server → Vector API をAuth Server → Vector Gatewayに変更。Vector Gatewayは透過的に動作するため、Circuit Breaker設定自体に変更はない。

#### 状態遷移図

```
                    失敗 5回/10秒
        ┌─────────────────────────────────┐
        │                                 ▼
    ┌───────┐                        ┌────────┐
    │Closed │                        │  Open  │
    └───┬───┘                        └────┬───┘
        ▲                                 │
        │ 成功 2回                        │ 30秒経過
        │                                 ▼
        │                           ┌──────────┐
        └───────────────────────────┤Half-Open │
                                    └──────────┘
                                          │
                                          │ 失敗
                                          ▼
                                       [Open へ戻る]
```

#### 実装例（gobreaker使用）

```go
import "github.com/sony/gobreaker"

var cb *gobreaker.CircuitBreaker

func init() {
    settings := gobreaker.Settings{
        Name:        "vector-gateway",  // 変更: vector-api → vector-gateway
        MaxRequests: 3,                      // Half-Open時の許可数
        Interval:    10 * time.Second,       // 計測ウィンドウ
        Timeout:     30 * time.Second,       // Open維持時間
        ReadyToTrip: func(counts gobreaker.Counts) bool {
            return counts.ConsecutiveFailures >= 5
        },
        OnStateChange: func(name string, from, to gobreaker.State) {
            switch to {
            case gobreaker.StateOpen:
                slog.Warn("circuit breaker opened",
                    "event_id", "CB_OPEN",
                    "cb_name", name,
                    "failure_count", 5)
            case gobreaker.StateHalfOpen:
                slog.Info("circuit breaker half-open",
                    "event_id", "CB_HALF_OPEN",
                    "cb_name", name)
            case gobreaker.StateClosed:
                slog.Info("circuit breaker closed",
                    "event_id", "CB_CLOSE",
                    "cb_name", name,
                    "recovery_time_ms", recoveryTime.Milliseconds())
            }
        },
    }
    cb = gobreaker.NewCircuitBreaker(settings)
}
```

### 4.4 Graceful Degradation

#### 4.4.1 Valkey接続断時の動作

| コンポーネント | 動作 | 備考 |
|---------------|------|------|
| **Auth Server** | 全認証リクエストを Access-Reject | ログ出力継続 |
| **Acct Server** | Accounting-Response返却、データ欠損をログ記録 | ベストエフォート |
| **Vector Gateway** | 正常動作（Valkey未使用） | PoC段階ではValkey接続なし |
| **Vector API** | 500エラー応答 | |
| **Admin TUI** | エラー画面表示、再接続ボタン | |

**各コンポーネントのValkey停止時詳細動作:**

- **Auth Server:** Valkey停止中はEAPコンテキスト（`eap:{UUID}`）の保存/取得が不可となる。新規認証は即座にAccess-Rejectとなり、進行中の認証はEAPコンテキストTTL（60秒）超過により自動的に失敗する。
- **Acct Server:** Valkey停止中はセッション情報（`sess:{UUID}`）の記録/更新が不可となる。NAS側のリトライに依存するため、Valkey復旧後にNASが再送するパケットで処理を継続する。
- **Vector API:** Valkey停止中は加入者データ（`sub:{IMSI}`）の取得が不可となる。500 Internal Server Errorを返却し、Auth Server側のCircuit Breakerが発動する。
- **Admin TUI:** 起動時にValkey接続失敗の場合はエラー画面を表示する。操作中にValkey接続が断絶した場合はステータスバーにエラーメッセージを表示する。

#### 4.4.2 Valkey再接続方針

| 項目 | 方針 |
|------|------|
| 再接続主体 | go-redisクライアントの自動再接続機能を利用 |
| 接続プール | 有効（デフォルト設定） |
| ヘルスチェック | go-redisの自動ヘルスチェックに依存 |
| 復旧検知 | コマンド成功時に `VALKEY_CONN_RESTORED` をログ出力 |

```go
// 接続復旧検知の実装例
var lastConnError time.Time
var mu sync.Mutex

func executeWithConnTracking(ctx context.Context, fn func() error) error {
    err := fn()
    
    mu.Lock()
    defer mu.Unlock()
    
    if err != nil {
        if isConnectionError(err) {
            lastConnError = time.Now()
        }
        return err
    }
    
    // 接続復旧を検知
    if !lastConnError.IsZero() {
        downtime := time.Since(lastConnError)
        slog.Info("valkey connection restored",
            "event_id", "VALKEY_CONN_RESTORED",
            "downtime_ms", downtime.Milliseconds())
        lastConnError = time.Time{}
    }
    return nil
}
```

#### 4.4.3 Vector Gateway障害時の動作（Auth Server）

| Circuit Breaker状態 | 動作 | レイテンシ影響 |
|---------------------|------|---------------|
| **Closed** | 通常処理、失敗時はカウント | 通常 |
| **Open** | 即座にAccess-Reject、Gateway呼び出しスキップ | 最小（即時応答） |
| **Half-Open** | 限定的に試行 | 試行時は通常、それ以外は最小 |

---

## 5. エラー応答仕様

### 5.1 RADIUS応答マッピング

| 状況 | RADIUS Code | EAP含有 | 備考 |
|------|-------------|---------|------|
| 認証成功 | Access-Accept (2) | EAP-Success | 通常応答 |
| 認証失敗（全般） | Access-Reject (3) | EAP-Failure | 認証エラー、データエラー |
| チャレンジ送信 | Access-Challenge (11) | EAP-Request | 正常フロー |
| フル認証誘導 | Access-Challenge (11) | EAP-Request/AKA-Identity | 仮名/再認証ID受信時 |
| 不正パケット（RADIUSレイヤー） | なし | - | 無応答 |
| 課金応答 | Accounting-Response (5) | - | 常に応答 |

### 5.2 HTTP応答マッピング（Vector Gateway）

| 状況 | HTTP Status | Problem Type | 備考 |
|------|-------------|--------------|------|
| 成功 | 200 OK | - | ベクター返却（透過） |
| リクエスト不正 | 400 Bad Request | Bad Request | IMSI形式不正等 |
| IMSI未登録 | 404 Not Found | User Not Found | Vector APIからの透過 |
| 未実装バックエンド | 501 Not Implemented | Not Implemented | 接続方式ID未実装 |
| バックエンド通信エラー | 502 Bad Gateway | Bad Gateway | Vector API接続失敗 |
| サーバーエラー | 500 Internal Server Error | Internal Error | Vector APIからの透過 |

### 5.3 HTTP応答マッピング（Vector API）

| 状況 | HTTP Status | Problem Type | 備考 |
|------|-------------|--------------|------|
| 成功 | 200 OK | - | ベクター返却 |
| IMSI未登録 | 404 Not Found | User Not Found | |
| リクエスト不正 | 400 Bad Request | Bad Request | IMSI形式不正、再同期失敗 |
| サーバーエラー | 500 Internal Server Error | Internal Error | Valkey障害、計算エラー |

### 5.4 TUIエラー表示

| エラー種別 | 表示場所 | 表示色 | 自動消去 |
|-----------|---------|-------|---------|
| 接続エラー（起動時） | 全画面ダイアログ | 赤 | なし（手動操作必要） |
| 接続エラー（操作中） | ステータスバー | 赤 | なし |
| バリデーションエラー | フィールド下 | 赤 | なし（修正まで） |
| インポートエラー | サマリダイアログ | 赤 | なし（確認後消去） |
| 操作成功 | ステータスバー | 緑 | 3秒 |
| 警告 | ステータスバー | 黄 | 5秒 |

---

## 6. エラーログ仕様（追加分）

ログ仕様設計書(r4)に追加するevent_id定義。

### 6.1 通信エラー関連

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `VALKEY_CONN_ERR` | Valkey接続失敗 | ERROR | `error`, `retry_count` |
| `VALKEY_CONN_RESTORED` | Valkey接続復旧 | INFO | `downtime_ms` |
| `VALKEY_AUTH_ERR` | Valkey認証失敗 | ERROR | `error` |
| `VECTOR_API_ERR` | Vector Gateway呼び出し失敗 | ERROR | `error`, `http_status`, `latency_ms` |

### 6.2 Circuit Breaker関連

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `CB_OPEN` | Circuit Breaker Open遷移 | WARN | `cb_name`, `failure_count` |
| `CB_HALF_OPEN` | Circuit Breaker Half-Open遷移 | INFO | `cb_name` |
| `CB_CLOSE` | Circuit Breaker Close遷移 | INFO | `cb_name`, `recovery_time_ms` |

### 6.3 プロトコルエラー関連（RADIUS）

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `RADIUS_PARSE_ERR` | RADIUSパケットパース失敗 | WARN | `src_ip`, `reason` |
| `RADIUS_AUTH_ERR` | Message-Authenticator検証失敗 | WARN | `src_ip` |
| `RADIUS_NO_SECRET` | Shared Secret不明 | WARN | `src_ip` |
| `RADIUS_UNKNOWN_CODE` | 未知のRADIUSコード | WARN | `src_ip`, `code` |

### 6.4 プロトコルエラー関連（EAP）

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `EAP_PARSE_ERR` | EAPパケットパース失敗 | WARN | `src_ip`, `reason` |
| `EAP_UNKNOWN_SUBTYPE` | 未知のEAPサブタイプ（AT_xxx） | WARN | `src_ip`, `subtype` |
| `EAP_UNSUPPORTED_TYPE` | 非対応EAP方式検出 | INFO | `src_ip`, `eap_type` |
| `EAP_IDENTITY_INVALID` | Identity形式不正 | WARN | `src_ip`, `identity` |
| `EAP_PSEUDONYM_FALLBACK` | 仮名/高速再認証からフル認証へ誘導 | INFO | `src_ip`, `identity_type` |
| `EAP_CLIENT_ERROR` | AKA-Client-Error受信 | WARN | `src_ip`, `imsi`, `error_code` |
| `EAP_AUTH_REJECT` | AKA-Authentication-Reject受信 | WARN | `src_ip`, `imsi` |

### 6.5 認証エラー関連

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `AUTH_RES_MISMATCH` | AT_RESとXRESが不一致 | WARN | `trace_id`, `imsi` |
| `AUTH_MAC_INVALID` | AT_MAC検証失敗 | WARN | `trace_id`, `imsi` |
| `AUTH_IMSI_NOT_FOUND` | IMSI未登録 | INFO | `trace_id`, `imsi` |
| `AUTH_POLICY_NOT_FOUND` | ポリシー未設定 | INFO | `trace_id`, `imsi` |
| `AUTH_POLICY_DENIED` | ポリシールール不一致 | INFO | `trace_id`, `imsi`, `nas_id`, `ssid` |
| `AUTH_CONTEXT_NOT_FOUND` | EAPコンテキスト不在 | WARN | `trace_id` |
| `AUTH_TIMEOUT` | EAPコンテキストTTL超過 | WARN | `trace_id`, `stage` |
| `AUTH_RESYNC_LIMIT` | 再同期リトライ上限超過 | WARN | `trace_id`, `imsi`, `resync_count` |

### 6.6 データエラー関連（Accounting）

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `ACCT_SESSION_NOT_FOUND` | sess:{UUID}不在 | WARN | `src_ip`, `class_uuid` |
| `ACCT_SESSION_EXPIRED` | セッションTTL超過 | WARN | `src_ip`, `class_uuid` |
| `ACCT_DUPLICATE_START` | 重複Start受信 | WARN | `src_ip`, `acct_session_id` |
| `ACCT_SEQUENCE_ERR` | 順序異常 | WARN | `src_ip`, `acct_session_id`, `reason` |

### 6.7 計算エラー関連（Vector API）

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `CALC_ERR` | 計算エラー（一般） | ERROR/INFO | `imsi`, `http_status`, `reason` |
| `SQN_RESYNC` | SQN再同期実行 | INFO | `imsi`, `sqn_old`, `sqn_new` |
| `SQN_RESYNC_MAC_ERR` | AUTS MAC検証失敗 | WARN | `imsi` |
| `SQN_RESYNC_FORMAT_ERR` | AUTS形式不正 | WARN | `imsi` |
| `SQN_RESYNC_DECODE_ERR` | SQN抽出失敗 | WARN | `imsi` |

### 6.8 ルーティング・バックエンド関連（Vector Gateway）

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `PLMN_ROUTE_MATCH` | PLMNマッチでバックエンド選択 | DEBUG | `trace_id`, `plmn`, `backend_id` |
| `PLMN_ROUTE_UNMATCH` | PLMNマップに未登録（デフォルト動作） | DEBUG | `trace_id`, `imsi`（マスク済み） |
| `BACKEND_INTERNAL_CALL` | 内部Vector API呼び出し | INFO | `trace_id`, `imsi`（マスク済み）, `backend_id`, `backend_name` |
| `BACKEND_INTERNAL_ERR` | 内部Vector API呼び出し失敗 | ERROR | `trace_id`, `error`, `http_status`, `latency_ms` |
| `BACKEND_NOT_IMPLEMENTED` | 未実装接続方式ID（501返却） | WARN | `trace_id`, `backend_id` |
| `REQUEST_INVALID` | リクエスト形式不正 | WARN | `trace_id`, `reason` |
| `GW_REQUEST_OK` | リクエスト処理成功 | INFO | `trace_id`, `imsi`（マスク済み）, `backend_id`, `latency_ms`, `http_status` |

#### 将来追加予定（外部API連携時）

| event_id | 発生条件 | レベル | 追加フィールド |
|----------|---------|--------|---------------|
| `BACKEND_EXTERNAL_CALL` | 外部API呼び出し | INFO | `trace_id`, `imsi`（マスク済み）, `backend_id`, `external_endpoint` |
| `BACKEND_EXTERNAL_ERR` | 外部API呼び出し失敗 | ERROR | `trace_id`, `error`, `http_status`, `latency_ms` |
| `EXTERNAL_AUTH_ERR` | 外部API認証失敗 | ERROR | `trace_id`, `backend_id` |
| `EXTERNAL_RATE_LIMIT` | 外部API Rate Limit | WARN | `trace_id`, `backend_id` |

---

## 7. 実装ガイドライン

### 7.1 Go実装パターン

#### エラー定義

アプリケーション固有のエラーは専用の型を定義する。

```go
package apperr

import "errors"

// センチネルエラー
var (
    ErrIMSINotFound       = errors.New("IMSI not found")
    ErrPolicyNotFound     = errors.New("policy not found")
    ErrPolicyDenied       = errors.New("policy denied")
    ErrAuthFailed         = errors.New("authentication failed")
    ErrAuthResMismatch    = errors.New("RES mismatch")
    ErrAuthMACInvalid     = errors.New("MAC verification failed")
    ErrAuthTimeout        = errors.New("EAP context timeout")
    ErrAuthResyncLimit    = errors.New("resync limit exceeded")
    ErrValkeyConnection   = errors.New("valkey connection failed")
    ErrVectorAPI          = errors.New("vector API error")
    ErrUnsupportedEAPType = errors.New("unsupported EAP type")
    
    // Vector Gateway用エラー
    ErrBackendNotImplemented = errors.New("backend not implemented")
    ErrBackendCommunication  = errors.New("backend communication failed")
    ErrInvalidRequest        = errors.New("invalid request")
)

// 詳細情報を持つエラー
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error: %s - %s", e.Field, e.Message)
}

type EAPIdentityError struct {
    Identity     string
    IdentityType string
    Reason       string
}

func (e *EAPIdentityError) Error() string {
    return fmt.Sprintf("EAP identity error: type=%s, reason=%s", e.IdentityType, e.Reason)
}

// Vector Gateway用エラー型
type BackendNotImplementedError struct {
    ID string
}

func (e *BackendNotImplementedError) Error() string {
    return fmt.Sprintf("backend not implemented: %s", e.ID)
}

type BackendCommunicationError struct {
    BackendID  string
    StatusCode int
    Cause      error
}

func (e *BackendCommunicationError) Error() string {
    return fmt.Sprintf("backend %s communication failed: status=%d, cause=%v", e.BackendID, e.StatusCode, e.Cause)
}
```

#### エラーラッピング

エラーはコンテキスト情報を追加してラッピングする。

```go
// 良い例
if err := valkey.Get(ctx, key).Err(); err != nil {
    if errors.Is(err, redis.Nil) {
        return nil, fmt.Errorf("subscriber %s: %w", imsi, apperr.ErrIMSINotFound)
    }
    return nil, fmt.Errorf("get subscriber %s: %w", imsi, err)
}

// 悪い例（コンテキスト情報なし）
if err := valkey.Get(ctx, key).Err(); err != nil {
    return nil, err
}
```

#### エラーハンドリングの一貫性

ハンドラー層でエラーを分類し、適切な応答を返す。

```go
func handleAuthRequest(ctx context.Context, req *radius.Packet) *radius.Packet {
    result, err := processAuth(ctx, req)
    if err != nil {
        // エラー種別に応じた応答とログ出力
        switch {
        case errors.Is(err, apperr.ErrIMSINotFound):
            slog.Info("authentication failed",
                "event_id", "AUTH_IMSI_NOT_FOUND",
                "imsi", extractIMSI(err))
            return buildReject(req, eap.Failure)
            
        case errors.Is(err, apperr.ErrPolicyNotFound):
            slog.Info("authentication failed",
                "event_id", "AUTH_POLICY_NOT_FOUND",
                "imsi", extractIMSI(err))
            return buildReject(req, eap.Failure)
            
        case errors.Is(err, apperr.ErrAuthResMismatch):
            slog.Warn("authentication failed",
                "event_id", "AUTH_RES_MISMATCH",
                "imsi", extractIMSI(err))
            return buildReject(req, eap.Failure)
            
        case errors.Is(err, apperr.ErrValkeyConnection):
            slog.Error("valkey connection error",
                "event_id", "VALKEY_CONN_ERR",
                "error", err.Error())
            return buildReject(req, eap.Failure)
            
        default:
            slog.Error("unexpected error",
                "event_id", "SYS_ERR",
                "error", err.Error())
            return buildReject(req, eap.Failure)
        }
    }
    return result
}
```

#### Vector Gatewayのエラーハンドリング

```go
// Vector Gatewayのハンドラー層
func (h *VectorHandler) HandleVector(c *gin.Context) {
    var req VectorRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        slog.Warn("invalid request",
            "event_id", "REQUEST_INVALID",
            "trace_id", getTraceID(c),
            "reason", err.Error())
        h.writeError(c, http.StatusBadRequest, "Bad Request", err.Error())
        return
    }
    
    resp, err := h.service.GetVector(c.Request.Context(), &req)
    if err != nil {
        h.handleError(c, err)
        return
    }
    
    c.JSON(http.StatusOK, resp)
}

func (h *VectorHandler) handleError(c *gin.Context, err error) {
    traceID := getTraceID(c)
    
    var notImplErr *apperr.BackendNotImplementedError
    if errors.As(err, &notImplErr) {
        slog.Warn("backend not implemented",
            "event_id", "BACKEND_NOT_IMPLEMENTED",
            "trace_id", traceID,
            "backend_id", notImplErr.ID)
        h.writeError(c, http.StatusNotImplemented, "Not Implemented",
            fmt.Sprintf("Backend ID %s is not implemented", notImplErr.ID))
        return
    }
    
    var commErr *apperr.BackendCommunicationError
    if errors.As(err, &commErr) {
        slog.Error("backend communication failed",
            "event_id", "BACKEND_INTERNAL_ERR",
            "trace_id", traceID,
            "backend_id", commErr.BackendID,
            "http_status", commErr.StatusCode,
            "error", commErr.Cause.Error())
        h.writeError(c, http.StatusBadGateway, "Bad Gateway",
            "Failed to communicate with internal Vector API")
        return
    }
    
    // その他のエラー
    slog.Error("unexpected error",
        "event_id", "SYS_ERR",
        "trace_id", traceID,
        "error", err.Error())
    h.writeError(c, http.StatusInternalServerError, "Internal Error", "An unexpected error occurred")
}

func (h *VectorHandler) writeError(c *gin.Context, status int, title, detail string) {
    c.JSON(status, gin.H{
        "type":   "about:blank",
        "title":  title,
        "detail": detail,
        "status": status,
    })
}
```

### 7.2 エラーラッピング規約

| レイヤー | 責務 | 例 |
|---------|------|-----|
| **Repository層** | 生エラーにキー情報を付加 | `fmt.Errorf("get sub:%s: %w", imsi, err)` |
| **Service層** | ビジネスエラーへの変換 | `apperr.ErrIMSINotFound` |
| **Handler層** | ログ出力と応答生成 | `slog.Error(...)` + RADIUS応答 |
| **Gateway層** | ルーティングエラーへの変換 | `&apperr.BackendNotImplementedError{ID: backendID}` |

---

## 8. 未決事項・将来検討

| No. | 項目 | 内容 | 判断時期 |
|-----|------|------|---------|
| 1 | Valkey接続プール設定 | 最大接続数、アイドルタイムアウト | 実装時 |
| 2 | メトリクス収集 | Prometheus等による監視 | PoC完了後 |
| 3 | アラート通知 | 障害時のSlack/メール通知 | PoC完了後 |
| 4 | 分散トレーシング | OpenTelemetry対応 | PoC完了後 |
| 5 | 外部API連携時のエラー処理 | Rate Limit、認証エラー等 | 外部API仕様確定後 |

---

## 改訂履歴

| 版数 | 日付 | 内容 |
|------|------|------|
| r1 | 2025-12-28 | 初版 |
| r2 | 2025-12-30 | レビュー反映：Identity判定ロジック詳細化、フル認証誘導手順追加、再同期リトライ上限(32回)、event_id細分化、PoC対象外機能明記、セッションTTL超過対応、Valkey再接続方針追加 |
| r3 | 2026-01-06 | Vector Gateway追加：対象範囲にVector Gateway追加、セクション3.3にVector Gatewayエラー処理追加、501 Not Implementedエラー処理追加、タイムアウト/リトライ設定にVector Gateway追加、セクション6.8にルーティング・バックエンド関連event_id追加、エラー定義にVector Gateway用追加、関連ドキュメント版数更新 |
| r4 | 2026-01-26 | SQN競合制御対応: セクション3.4.3にSQN競合上限超過エラー（409 Conflict）追加、セクション3.4.4に409エラー応答例追加 |
| r5 | 2026-01-27 | API接続設計統一: 関連ドキュメント版数更新（D-03 r2→r4） |
| r6 | 2026-02-18 | PolicyRule新構造反映、Valkey停止時動作追記、関連ドキュメント版数更新 |
